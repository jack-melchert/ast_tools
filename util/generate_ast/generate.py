import ast
import datetime
import inspect
from os import path
import sys

_BASE_PATH = path.dirname(__file__)
def _make_path(f):
    return path.abspath(path.join(_BASE_PATH, f))

META_FILE = _make_path('_meta.px')
FUNCTIONS_FILE = _make_path('_functions.px')
AST_BASE_FILE = _make_path('_base.px')
TAB = ' '*4

def generate_class(name, bases, fields):
    bases=', '.join(bases) + (', ' if bases else '')
    sig = (', ' if fields else '') + ', '.join(fields)
    body = [f'self.{arg} = {arg}' for arg in fields]
    if not body:
        body.append('pass')

    body = f'\n{TAB}{TAB}'.join(body)

    class_ = f'''\
class {name}({bases}mutable=ast.{name}):
{TAB}_fields={fields}
{TAB}def __init__(self{sig}):
{TAB}{TAB}{body}
'''

    return class_

def generate_classes(class_tree, ALL):
    cls_to_args = {ast.AST : ('AST', (), ())}

    def pop_args_from_tree(tree):
        for item in tree:
            if isinstance(item, list):
                r = pop_args_from_tree(item)
                if r is not None:
                    return r
            elif item[0] not in cls_to_args:
                cls = item[0]
                bases = tuple(cls_to_args[base][0] for base in item[1] if base is not object)
                cls_to_args[cls] = r = cls.__name__, bases,  cls._fields
                return r

    classes_ = []

    args = pop_args_from_tree(class_tree[1])
    while args is not None:
        class_ = generate_class(*args)
        classes_.append(class_)
        ALL.append(args[0])
        args = pop_args_from_tree(class_tree[1])

    return '\n'.join(classes_)


def generate_immutable_ast():
    def _issubclass(t, types):
        try:
            return issubclass(t, types)
        except TypeError:
            pass
        return False

    classes = []
    for name in dir(ast):
        obj = getattr(ast, name)
        if _issubclass(obj, ast.AST):
            classes.append(obj)

    class_tree = inspect.getclasstree(classes)
    # assert the class tree is a tree and not a dag
    assert class_tree == inspect.getclasstree(classes, unique=True)
    # assert the class tree has a root
    assert len(class_tree) == 2, class_tree[0]
    # assert the root is object
    assert class_tree[0][0] is object, class_tree[0][0]
    # assert the root has only 1 child
    assert len(class_tree[1]) == 2, class_tree[1]
    # assert that the child is ast.AST
    assert class_tree[1][0][0] is ast.AST, class_tree[1][0]

    nl = '\n'
    head_comment = f'''\
# file generated by {__file__} on {datetime.datetime.now()}
# for python {sys.version.split(nl)[0].strip()}'''

    version_check = f'''\
if sys.version_info[:2] != {sys.version_info[:2]}:
{TAB}warnings.warn(f"{{__file__}} generated for {sys.version_info[:2]}"
{TAB}              f"does not match system version {{sys.version_info[:2]}}")'''



    ALL = ['AST']

    with open(FUNCTIONS_FILE, 'r') as f:
        functions = f.read()

    with open(META_FILE, 'r') as f:
        meta = f.read()

    with open(AST_BASE_FILE, 'r') as f:
        ast_base = f.read()

    classes = generate_classes(class_tree, ALL)

    immutable_ast = f'''\
{head_comment}

import ast
import sys
import typing as tp
import warnings

{version_check}

__ALL__ = {ALL}

{functions}

{meta}

{ast_base}

{classes}
'''
    return immutable_ast
