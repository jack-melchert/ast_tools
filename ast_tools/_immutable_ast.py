import functools as ft
import ast

__ALL__ = ['ImmutableMeta', 'immutable', 'mutable']

class ImmutableMeta(type):
    _immutable_to_mutable = dict()
    _mutable_to_immutable = dict()
    def __new__(mcs, name, bases, namespace, mutable, **kwargs):
        def __setattr__(self, attr, value):
            if attr in self._fields and hasattr(self, attr):
                raise AttributeError('Cannot modify ImmutableAST fields')
            elif isinstance(value, (list, ast.AST)):
                value = immutable(value)

            self.__dict__[attr] = value

        def __delattr__(self, attr):
            if attr in self._fields:
                raise AttributeError('Cannot modify ImmutableAST fields')
            del self.__dict__[attr]

        def __hash__(self):
            try:
                return self._hash_
            except AttributeError:
                pass

            h = hash(type(self))
            for _, n in ast.iter_fields(self):
                if isinstance(type(n), ImmutableMeta):
                    h += hash(n)
                elif isinstance(n, tp.Sequence):
                    for c in n:
                        h += hash(c)
                else:
                    h += hash(n)
            self._hash_ = h
            return h


        def __eq__(self, other):
            if not isinstance(other, type(self)):
                return NotImplemented
            elif type(self) == type(other):
                for f in self._fields:
                    if getattr(self, f) != getattr(other, f):
                        return False
                return True
            else:
                return False


        def __ne__(self, other):
            return not (self == other)

        namespace['__setattr__'] = __setattr__
        namespace['__delattr__'] = __delattr__
        namespace['__hash__'] = __hash__
        namespace['__eq__'] = __eq__
        namespace['__ne__'] = __ne__

        cls = super().__new__(mcs, name, bases, namespace, **kwargs)

        ImmutableMeta._immutable_to_mutable[cls] = mutable
        ImmutableMeta._mutable_to_immutable[mutable] = cls

        return cls

    def __instancecheck__(cls, instance):
        return super().__instancecheck__(instance)\
                or isinstance(instance, ImmutableMeta._immutable_to_mutable[cls])

    def __subclasscheck__(cls, type_):
        return super().__subclasscheck__(type_)\
                or issubclass(type_, ImmutableMeta._immutable_to_mutable[cls])


def _cast_tree(seq_t, n_seq_t, type_look_up, tree):
    args = seq_t, n_seq_t, type_look_up

    if isinstance(tree, seq_t):
        return n_seq_t(_cast_tree(*args, c) for c in tree)

    try:
        T = type_look_up[type(tree)]
    except KeyError:
        return tree

    kwargs = {}
    for field, c in ast.iter_fields(tree):
        kwargs[field] = _cast_tree(*args, c)

    return T(**kwargs)


def immutable(tree: ast.AST):
    '''Converts a mutable ast to an immutable one'''
    return _cast_tree(list, tuple, ImmutableMeta._mutable_to_immutable, tree)

def mutable(tree: 'AST'):
    '''Converts an immutable ast to a mutable one'''
    return _cast_tree(tuple, list, ImmutableMeta._immutable_to_mutable, tree)


# could actually generate the classes and put them in globals
# but that would make text editors suck (no autocomplete etc)
# so Instead generate the actual file
def _generate_immutable_ast():
    import ast
    import inspect
    import sys
    import datetime

    immutable_ast_template = '''\
{head_comment}

import ast
import sys
import warnings

from ._immutable_ast import *

{version_check}

__ALL__ = {ALL}

{classes}
'''

    class_template = '''\
class {name}({bases}mutable=ast.{name}{meta}):
{tab}_fields={fields}
{tab}def __init__(self{sig}):'''

    builder_template = '{tab}{tab}self.{arg} = {arg}'

    tab = ' '*4

    pass_string = f'{tab}{tab}pass'

    nl = '\n'
    head_comment = f'''\
# file generated by {__file__} on {datetime.datetime.now()}
# for python {sys.version.split(nl)[0].strip()}'''

    version_check = f'''\
if sys.version_info[:2] != {sys.version_info[:2]}:
{tab}warnings.warn(f"{{__file__}} generated for {sys.version_info[:2]}"
{tab}              f"does not match system version {{sys.version_info[:2]}}")'''

    def _issubclass(t, types):
        try:
            return issubclass(t, types)
        except TypeError:
            pass
        return False

    _classes = []
    for _name in dir(ast):
        _obj = getattr(ast, _name)
        if _issubclass(_obj, ast.AST):
            _classes.append(_obj)

    _class_tree = inspect.getclasstree(_classes)
    assert _class_tree == inspect.getclasstree(_classes, unique=True)
    _cls_to_args = {}

    def _build_cls_from_tree(tree):
        for item in tree:
            if isinstance(item, list):
                r = _build_cls_from_tree(item)
                if r is not None:
                    return r
            elif item[0] not in _cls_to_args:
                cls = item[0]
                bases = tuple(_cls_to_args[base][0] for base in item[1] if base is not object)
                _cls_to_args[cls] = r = cls.__name__, bases,  cls._fields
                return r


    _class_strings = []
    _all = []
    _args = _build_cls_from_tree(_class_tree[1])
    while _args is not None:
        name=_args[0]
        bases=', '.join(_args[1])
        if bases != '':
            bases += ', '
            meta=''
        else:
            meta=', metaclass=ImmutableMeta'


        fields = _args[2]

        if fields:
            sig = ', '
        else:
            sig = ''
        sig += ', '.join(fields)

        class_ = [class_template.format(
            tab=tab,
            name=name,
            bases=bases,
            meta=meta,
            fields=fields,
            sig=sig,
        )]

        if fields:
            for arg in fields:
                class_.append(builder_template.format(
                    tab=tab,
                    arg=arg,
                ))
        else:
            class_.append(pass_string)

        class_.append('\n')
        _class_strings.append('\n'.join(class_))
        _all.append(name)
        _args = _build_cls_from_tree(_class_tree[1])


    return immutable_ast_template.format(
        head_comment=head_comment,
        version_check=version_check,
        ALL=_all,
        classes = '\n'.join(_class_strings)
    )


if __name__ == '__main__':
    s = _generate_immutable_ast()
    with open('immutable_ast.py', 'w') as f:
        f.write(s)

